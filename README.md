## Введение
Мониторинг позволяет вовремя выявлять проблемы в системе, а оповещения через такие инструменты, как Grafana OnCall, 
помогают команде быстро реагировать. В статье описано, как связать между собой различные инструменты, чтобы инцидент 
автоматически отслеживался от правила мониторинга до уведомления в мессенджере. 
Это особенно полезно для DevOps инженеров, строящих надёжную систему мониторинга.

## Преимущества маршрутизации алертов через OnCall
Если слать алерты напрямую из Alertmanager в Telegram, уведомления всегда будут приходить в один и тот же чат или
нескольким людям сразу, что неудобно при сменах дежурств и может привести к потере ответственности — все видят
сообщение, но никто не обязан реагировать. Нет удобного контроля, кто сейчас отвечает, сложно отличить рабочие
часы от нерабочих, невозможно управлять графиком дежурств.

Если же передавать оповещения из Alertmanager в Grafana OnCall, а уже оттуда — в Telegram, появляются важные
преимущества. Grafana OnCall позволяет вести расписание дежурств: вы указываете, кто и когда на смене, и только
этот человек получает уведомление. Также доступна эскалация — если дежурный не отреагировал за определённое время,
алерт пересылается следующему ответственному или целой группе, чтобы инцидент не остался без внимания. Через Grafana
OnCall можно подтвердить получение сообщения ("Acknowledge").

Таким образом, связка Alertmanager → Grafana OnCall → Telegram обеспечивает централизованный, управляемый и
прозрачный процесс реагирования на инциденты, автоматизирует учёт дежурств, поддерживает эскалацию и позволяет
отслеживать подтверждение алертов.

## Общая схема прохождения алерта
### Архитектура решения
В данной архитектуре для мониторинга метрик используется Prometheus-совместимая система — VictoriaMetrics с её 
компонентом vmalert. Сначала создаётся alert rule (правило срабатывания) и применяется 
к vmalert. Как только условие правила выполняется, vmalert формирует алерт и отправляет его в Alertmanager. Alertmanager 
занимается маршрутизацией алертов, их группировкой, устранением дублирования и переадресацией по настройкам. Следующий 
этап — передача алерта из Alertmanager в Grafana OnCall, который уже отвечает за координацию оповещений: учитывает 
расписания дежурных, каналы связи и собственную логику эскалаций. После обработки события в OnCall ответственным 
лицам отправляется уведомление — в нашем случае посредством Telegram.

Такой подход позволяет гибко настроить процесс реагирования на инциденты: алерты по цепочке проходят через все нужные 
этапы фильтрации, маршрутизации и эскалации для быстрого и адресного оповещения нужных сотрудников.

### Визуальная схема (диаграмма прохождения алерта)
```
Prometheus Rule → vmalert → Alertmanager → Grafana OnCall → Telegram
```
Эта диаграмма отражает основной путь прохождения алерта — от возникновения события в метриках до получения уведомления 
в мессенджере ответственным сотрудником.

## VMAlert: обработка и маршрутизация алертов
### Что такое VMAlert
VMAlert — это компонент стека мониторинга VictoriaMetrics, предназначенный для оценки правил алертинга (alerting rules)
в стиле Prometheus и генерации алертов на их основе. VMAlert берет на вход файл (или список файлов) с alert rule'ами,
периодически опрашивает метрики (как правило, из VictoriaMetrics или Prometheus-compatible источников), вычисляет
выражения и при их срабатывании формирует события алерта. Далее он направляет сформированные алерты в Alertmanager
для дальнейшей маршрутизации и обработки.

### Создадим prometheus rule, которое будет алертить всегда для тестирования цепочки

Для тестирования всей цепочки прохождения алерта, логично начать с самого простого варианта — создать правило, которое 
будет алертить всегда, независимо от состояния системы. Это позволит убедиться, что весь процесс — от генерации события 
до получения уведомления в Telegram — работает корректно.

Создадим yaml-файл с Prometheus alert rule, например, `always-fire-rule.yaml`:

```yaml
groups:
  - name: always-fire
    rules:
      - alert: AlwaysFiring
        expr: 1 == 1
        for: 1m
        labels:
          severity: test
        annotations:
          summary: "Тестовое оповещение: Always firing"
          description: "Это тестовый алерт для проверки прохождения цепочки уведомлений."
```

Это правило срабатывает всегда, поскольку выражение `1 == 1` всегда истинно. Мы задаём небольшую продолжительность 
`for: 1m`, после чего алерт переходит в состояние firing. Внутри правила мы также указываем произвольные метки и 
аннотации, которые пригодятся для идентификации тестового оповещения при просмотре в Grafana OnCall или получении 
в Telegram.

## Установка Kubernetes

Установка kubernetes через terraform
```shell
git clone https://github.com/patsevanton/gitlab-job-labels-to-victorialogs
export YC_FOLDER_ID='ваш folder_id'
terraform init
terraform apply
```

## Установка OnCall

```shell
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
helm upgrade --install oncall grafana/oncall \
    --namespace oncall \
    --create-namespace \
    --values oncall-values.yaml
```

## Установка victoria-metrics-k8s-stack

Добавим Helm репозиторий и установим VictoriaMetrics stack:

```bash
helm repo add vm https://victoriametrics.github.io/helm-charts/
helm repo update

helm upgrade --install vmks vm/victoria-metrics-k8s-stack \
  --namespace vmks --create-namespace \
  --values vmks-values.yaml
```

После установки, Grafana будет доступна по адресу http://grafana.apatsev.org.ru

Получение пароля grafana для admin юзера
```shell
kubectl get secret vmks-grafana -n vmks -o jsonpath='{.data.admin-password}' | base64 --decode
```

### Описание интеграции с Alertmanager

Для интеграции Alertmanager с Grafana OnCall достаточно добавить в конфигурацию Alertmanager соответствующий 
получатель (receiver) с webhook-URL, предоставленным Grafana OnCall. Пример конфигурации может выглядеть 
следующим образом:

```yaml
global:
  resolve_timeout: 5m

route:
  receiver: 'oncall-webhook'
  group_by: ['alertname', 'cluster']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 3h

receivers:
  - name: 'oncall-webhook'
    webhook_configs:
      - url: 'https://YOUR_ONCALL_URL/webhook/prometheus?integration_key=YOUR_INTEGRATION_KEY'
        send_resolved: true
```

В этом примере создаётся receiver (получатель) с именем `oncall-webhook`, который использует webhook для отправки 
алертов напрямую в Grafana OnCall. В URL указывается уникальный путь интеграции и ключ, который можно получить в 
настройках Grafana OnCall для вашей службы. Опция `send_resolved` позволяет уведомлять OnCall также о том, что 
алерт был устранён.

### Подключение источника алертов
Для интеграции Grafana OnCall c системой мониторинга, построенной на базе Prometheus и VictoriaMetrics, необходимо 
корректно связать цепочку генерации и доставки алертов:  
Prometheus генерирует alert согласно заданным правилам и отправляет их в компонент vmalert (часть VictoriaMetrics), 
который транслирует эти алерты в Alertmanager. Alertmanager, в свою очередь, выполняет агрегацию, группировку и 
маршрутизацию алертов, а затем пересылает их в Grafana OnCall.

Чтобы Alertmanager мог отправлять алерты в Grafana OnCall, нужно в конфигурационный файл Alertmanager (обычно это 
`alertmanager.yml`) добавить новый webhook receiver с endpoint, предоставляемым OnCall. Затем, в пользовательском 
интерфейсе OnCall, создаётся интеграция типа Alertmanager, где система генерирует URL, на который должны приходить 
алерты. Этот адрес и указывается в Alertmanager.

Например, фрагмент в `alertmanager.yml` может выглядеть так:
```yaml
receivers:
  - name: 'grafana-oncall'
    webhook_configs:
      - url: 'https://oncall.example.com/webhooks/alertmanager/xxxxxxxxxxxx'
```
После этого все алерты, направленные на receiver `grafana-oncall`, будут поступать в Grafana OnCall для 
дальнейшей обработки.

## Настройка Grafana OnCall для оповещения в Telegram
### Получение алертов в личных сообщениях Telegram
Чтобы получать нотификации в своих личных сообщениях Telegram и иметь возможность выполнять действия (подтвердить, 
решить, замолчать оповещение) прямо из чата:

- Откройте свой профиль в Grafana OnCall.
- Найдите настройку Telegram, нажмите “Connect”.
- Для автоматического подключения нажмите “Connect automatically”. OnCall-бот пришлёт вам сообщение — нажмите “Старт” 
- в Telegram и дождитесь подтверждения соединения.
- Теперь вы будете получать оповещения непосредственно в Telegram.

Если требуется подключить Telegram вручную:
- Используйте сгенерированную ссылку для начала диалога с OnCall-ботом и отправьте команду “Старт”.

## Заключение
Интеграция Grafana OnCall с Telegram — это быстрый способ организовать современную командную коммуникацию по 
инцидентам без лишней бюрократии. Grafana OnCall предоставляет централизованную платформу для эффективного 
управления алертами и инцидентами. Простота интеграции с популярными инструментами мониторинга и коммуникационными 
платформами, такими как Telegram, делает этот инструмент очень гибким. Благодаря OnCall команда может не переживать 
о том, что важные события останутся без внимания — каждый инцидент быстро доходит до ответственного человека. 
Интерфейс OnCall интуитивно понятен, а масштабирование и поддержка настроек пользователей позволяют оптимизировать 
рабочие процессы под каждую команду.

```
helm upgrade --install \
    --wait \
    --set base_url=oncall.apatsev.org.ru \
    --set grafana."grafana\.ini".server.domain=oncall.apatsev.org.ru \
    --set ingress-nginx.controller.service.loadBalancerIP="158.160.34.198" \
    helm-testing \
    grafana/oncall \
    --version 1.15.0
```

get password
```shell
kubectl get secret --namespace default helm-testing-grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
```
